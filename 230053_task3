"""

LIDAR to 2D grid map example

author: Erno Horvath, Csaba Hajdu based on Atsushi Sakai's scripts

"""

import math
from collections import deque

import matplotlib.pyplot as plt
import numpy as np

EXTEND_AREA = 1.0


def file_read(f):
    """
    Reading LIDAR laser beams (angles and corresponding distance data)
    """
    angles = []
    distances = []
    with open(f) as data:
        header = next(data)  # skip header line: angle_rad,distance_m
        # print("Header:", header)  # optional, for debugging

        for line in data:
            line = line.strip()
            if not line:
                continue  # skip empty lines
            parts = line.split(",")
            angles.append(float(parts[0]))
            distances.append(float(parts[1]))

    return np.array(angles), np.array(distances)




def bresenham(start, end):
    """
    Implementation of Bresenham's line drawing algorithm
    See en.wikipedia.org/wiki/Bresenham's_line_algorithm
    Bresenham's Line Algorithm
    Produces a np.array from start and end (original from roguebasin.com)
    >>> points1 = bresenham((4, 4), (6, 10))
    >>> print(points1)
    np.array([[4,4], [4,5], [5,6], [5,7], [5,8], [6,9], [6,10]])
    """
    # setup initial conditions
    x1, y1 = start
    x2, y2 = end
    dx = x2 - x1
    dy = y2 - y1
    is_steep = abs(dy) > abs(dx)  # determine how steep the line is
    if is_steep:  # rotate line
        x1, y1 = y1, x1
        x2, y2 = y2, x2
    # swap start and end points if necessary and store swap state
    swapped = False
    if x1 > x2:
        x1, x2 = x2, x1
        y1, y2 = y2, y1
        swapped = True
    dx = x2 - x1  # recalculate differentials
    dy = y2 - y1  # recalculate differentials
    error = int(dx / 2.0)  # calculate error
    y_step = 1 if y1 < y2 else -1
    # iterate over bounding box generating points between start and end
    y = y1
    points = []
    for x in range(x1, x2 + 1):
        coord = [y, x] if is_steep else (x, y)
        points.append(coord)
        error -= abs(dy)
        if error < 0:
            y += y_step
            error += dx
    if swapped:  # reverse the list if the coordinates were swapped
        points.reverse()
    points = np.array(points)
    return points


def calc_grid_map_config(ox, oy, xy_resolution):
    """
    Calculates the size, and the maximum distances according to the the
    measurement center
    """
    min_x = round(min(ox) - EXTEND_AREA / 2.0)
    min_y = round(min(oy) - EXTEND_AREA / 2.0)
    max_x = round(max(ox) + EXTEND_AREA / 2.0)
    max_y = round(max(oy) + EXTEND_AREA / 2.0)
    xw = int(round((max_x - min_x) / xy_resolution))
    yw = int(round((max_y - min_y) / xy_resolution))
    print("The grid map is ", xw, "x", yw, ".")
    return min_x, min_y, max_x, max_y, xw, yw


def atan_zero_to_twopi(y, x):
    angle = math.atan2(y, x)
    if angle < 0.0:
        angle += math.pi * 2.0
    return angle


def init_flood_fill(center_point, obstacle_points, xy_points, min_coord,
                    xy_resolution):
    """
    center_point: center point
    obstacle_points: detected obstacles points (x,y)
    xy_points: (x,y) point pairs
    """
    center_x, center_y = center_point
    prev_ix, prev_iy = center_x - 1, center_y
    ox, oy = obstacle_points
    xw, yw = xy_points
    min_x, min_y = min_coord
    occupancy_map = (np.ones((xw, yw))) * 0.5
    for (x, y) in zip(ox, oy):
        # x coordinate of the the occupied area
        ix = int(round((x - min_x) / xy_resolution))
        # y coordinate of the thel occupied area
        iy = int(round((y - min_y) / xy_resolution))
        free_area = bresenham((prev_ix, prev_iy), (ix, iy))
        for fa in free_area:
            occupancy_map[fa[0]][fa[1]] = 0  # free area 0.0
        prev_ix = ix
        prev_iy = iy
    return occupancy_map


def flood_fill(center_point, occupancy_map):
    """
    center_point: starting point (x,y) of fill
    occupancy_map: occupancy map generated from Bresenham ray-tracing
    """
    # Fill empty areas with queue method
    sx, sy = occupancy_map.shape
    fringe = deque()
    fringe.appendleft(center_point)
    while fringe:
        n = fringe.pop()
        nx, ny = n
        # West
        if nx > 0:
            if occupancy_map[nx - 1, ny] == 0.5:
                occupancy_map[nx - 1, ny] = 0.0
                fringe.appendleft((nx - 1, ny))
        # East
        if nx < sx - 1:
            if occupancy_map[nx + 1, ny] == 0.5:
                occupancy_map[nx + 1, ny] = 0.0
                fringe.appendleft((nx + 1, ny))
        # North
        if ny > 0:
            if occupancy_map[nx, ny - 1] == 0.5:
                occupancy_map[nx, ny - 1] = 0.0
                fringe.appendleft((nx, ny - 1))
        # South
        if ny < sy - 1:
            if occupancy_map[nx, ny + 1] == 0.5:
                occupancy_map[nx, ny + 1] = 0.0
                fringe.appendleft((nx, ny + 1))


def generate_ray_casting_grid_map(ox, oy, xy_resolution, breshen=True):
    """
    The breshen boolean tells if it's computed with bresenham ray casting
    (True) or with flood fill (False)
    """
    min_x, min_y, max_x, max_y, x_w, y_w = calc_grid_map_config(
        ox, oy, xy_resolution)
    # default 0.5 -- [[0.5 for i in range(y_w)] for i in range(x_w)]
    occupancy_map = np.ones((x_w, y_w)) / 2
    center_x = int(
        round(-min_x / xy_resolution))  # center x coordinate of the grid map
    center_y = int(
        round(-min_y / xy_resolution))  # center y coordinate of the grid map
    # occupancy grid computed with bresenham ray casting
    if breshen:
        for (x, y) in zip(ox, oy):
            # x coordinate of the the occupied area
            ix = int(round((x - min_x) / xy_resolution))
            # y coordinate of the the occupied area
            iy = int(round((y - min_y) / xy_resolution))
            laser_beams = bresenham((center_x, center_y), (
                ix, iy))  # line form the lidar to the occupied point
            for laser_beam in laser_beams:
                occupancy_map[laser_beam[0]][
                    laser_beam[1]] = 0.0  # free area 0.0
            occupancy_map[ix][iy] = 1.0  # occupied area 1.0
            occupancy_map[ix + 1][iy] = 1.0  # extend the occupied area
            occupancy_map[ix][iy + 1] = 1.0  # extend the occupied area
            occupancy_map[ix + 1][iy + 1] = 1.0  # extend the occupied area
    # occupancy grid computed with with flood fill
    else:
        occupancy_map = init_flood_fill((center_x, center_y), (ox, oy),
                                        (x_w, y_w),
                                        (min_x, min_y), xy_resolution)
        flood_fill((center_x, center_y), occupancy_map)
        occupancy_map = np.array(occupancy_map, dtype=float)
        for (x, y) in zip(ox, oy):
            ix = int(round((x - min_x) / xy_resolution))
            iy = int(round((y - min_y) / xy_resolution))
            occupancy_map[ix][iy] = 1.0  # occupied area 1.0
            occupancy_map[ix + 1][iy] = 1.0  # extend the occupied area
            occupancy_map[ix][iy + 1] = 1.0  # extend the occupied area
            occupancy_map[ix + 1][iy + 1] = 1.0  # extend the occupied area
    return occupancy_map, min_x, max_x, min_y, max_y, xy_resolution

def transform_points(ox, oy, tx, ty, yaw):
    """
    Apply 2D rigid-body transform to points (ox, oy).

    (ox, oy): points in the local LIDAR/robot frame
    (tx, ty): translation of that frame in the global map frame
    yaw:     rotation (radians) of that frame in the global map frame

    Returns:
        gx, gy: points in the global frame
    """
    cos_y = math.cos(yaw)
    sin_y = math.sin(yaw)

    # local -> global: [x_g] = R * [x_l] + t
    #                  [y_g]
    gx = cos_y * ox - sin_y * oy + tx
    gy = sin_y * ox + cos_y * oy + ty
    return gx, gy


def main():
    """
    Example usage: merge 3 LIDAR scans into a single global occupancy grid
    using known frame transformations (translation + rotation).
    """
    print(__file__, "start")

    # Grid resolution
    xy_resolution = 0.02  # meters per cell

   
    # 1) Define  three LIDAR data files
    scan_files = [
        "lidar_data_13.csv",
        "lidar_data_22.csv",
        "lidar_data_31.csv",   # or whatever your third file is
    ]

    # 2) Define poses (x, y, yaw) for each scan in the GLOBAL frame
    #    Units: meters, radians
    poses = [
        (0.0, 0.0, 0.0),                     # scan 1 at origin, facing +y
        (0.5, 0.0, math.radians(30.0)),      # scan 2 translated + rotated
        (1.0, 0.2, math.radians(-20.0)),     # scan 3 translated + rotated
    ]

    assert len(scan_files) == len(poses), "Number of scans and poses must match"

    # 3) Load all scans, convert to local Cartesian,
    #    then transform to global frame and concatenate
    all_ox_global = []
    all_oy_global = []

    for (fname, (tx, ty, yaw)) in zip(scan_files, poses):
        print(f"Reading {fname} at pose (x={tx}, y={ty}, yaw={yaw:.3f} rad)")
        ang, dist = file_read(fname)

        # Local coordinates in the LIDAR frame
        # NOTE: matching your original code:
        #   ox = sin(theta) * r
        #   oy = cos(theta) * r
        ox_local = np.sin(ang) * dist
        oy_local = np.cos(ang) * dist

        # Transform to global frame
        ox_global, oy_global = transform_points(ox_local, oy_local, tx, ty, yaw)

        all_ox_global.append(ox_global)
        all_oy_global.append(oy_global)

    # Concatenate all global points from the three scans
    ox = np.concatenate(all_ox_global)
    oy = np.concatenate(all_oy_global)

    # 4) Build a single global occupancy grid from the merged points
    occupancy_map, min_x, max_x, min_y, max_y, xy_resolution = \
        generate_ray_casting_grid_map(ox, oy, xy_resolution, True)

    xy_res = np.array(occupancy_map).shape

    # 5) Plot the merged map and the rays
    plt.figure(1, figsize=(10, 4))

    # Left: LIDAR points (in global frame)
    plt.subplot(121)
    plt.plot(oy, ox, "ro", markersize=2)  # flipped to match your previous convention
    plt.axis("equal")
    # Optionally plot robot poses
    for (tx, ty, yaw) in poses:
        plt.plot(ty, tx, "bx")  # same flip here
    plt.gca().set_aspect("equal", "box")
    bottom, top = plt.ylim()
    plt.ylim((top, bottom))
    plt.grid(True)
    plt.title("Merged LIDAR points (global frame)")

    # Right: occupancy grid
    plt.subplot(122)
    plt.imshow(occupancy_map, cmap="PiYG_r")
    plt.clim(-0.4, 1.4)
    plt.gca().set_xticks(np.arange(-.5, xy_res[1], 1), minor=True)
    plt.gca().set_yticks(np.arange(-.5, xy_res[0], 1), minor=True)
    plt.grid(True, which="minor", color="w", linewidth=0.6, alpha=0.5)
    plt.colorbar()
    plt.title("Merged occupancy grid")

    plt.show()

if __name__ == '__main__':
    print("Running lidar_to_grid_map.py as a script")
    main()

